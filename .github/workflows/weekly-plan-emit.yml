name: Weekly Plan and Emit

on:
  schedule:
    # Runs every Friday at 10:00 PM Pacific Time
    # PST (Winter): Friday 10:00 PM = Saturday 6:00 AM UTC
    # PDT (Summer): Friday 10:00 PM = Saturday 5:00 AM UTC
    # Using 6:00 AM UTC for PST; adjust to 5:00 during PDT if needed
    - cron: '0 6 * * 6'  # Every Saturday at 6:00 AM UTC

  workflow_dispatch:  # Allow manual triggering for testing
    inputs:
      date:
        description: 'Date to generate plan for (YYYY-MM-DD, leave empty for auto-calculate)'
        required: false
        type: string
      is_week_1:
        description: 'Is this Week 1? (true = 24 DH only, false = 6 DH + 6 D2DS)'
        required: false
        type: boolean
        default: true

# Required for git push
permissions:
  contents: write

env:
  PYTHON_VERSION: '3.11'

jobs:
  plan-and-emit:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Verify geospatial data
        run: |
          echo "Verifying geospatial data files..."
          ls -lh data/raw/DataSD/
          echo "✓ Geospatial data ready (included in repository)"

      - name: Download latest notification activities
        run: |
          echo "Downloading latest pothole data..."
          python -c "
          from utils.data_fetcher import fetch_latest_notification_activities
          activities = fetch_latest_notification_activities(use_local=False, download_if_missing=True)
          print(f'Downloaded {len(activities)} pothole records')
          "

      - name: Check historical plans (for bundle tracking)
        run: |
          echo "Historical plans for without-replacement sampling:"
          if [ -d "outputs/plans" ]; then
            ls -lh outputs/plans/bundles_plan_*.csv 2>/dev/null || echo "No historical plans found - this might be the first run"
          else
            echo "No plans directory - this might be the first run"
            mkdir -p outputs/plans
          fi

      - name: Calculate or use input date
        id: date
        run: |
          # Use manual input date if provided, otherwise calculate this Saturday
          if [ -n "${{ inputs.date }}" ]; then
            TARGET_DATE="${{ inputs.date }}"
            echo "Using manual input date: $TARGET_DATE"
          else
            # Calculate this coming Saturday (start of this week)
            # This workflow runs Friday 10pm PST = Saturday ~6am UTC
            # We want THIS Saturday, not next Saturday
            TARGET_DATE=$(python -c "from datetime import datetime, timedelta; today = datetime.now(); this_saturday = today if today.weekday() == 5 else (today + timedelta(days=1) if today.weekday() == 4 else today + timedelta(days=(5 - today.weekday()) % 7 or 7)); print(this_saturday.strftime('%Y-%m-%d'))")
            echo "Auto-calculated date: $TARGET_DATE"
          fi
          echo "next_saturday=$TARGET_DATE" >> $GITHUB_OUTPUT
          echo "Target date: $TARGET_DATE"

      - name: Validate date (check exclusions and end date)
        run: |
          TARGET_DATE="${{ steps.date.outputs.next_saturday }}"

          # Define excluded dates (holidays/breaks)
          EXCLUDED_DATES=("2026-05-23" "2026-07-04")

          # Define experiment end date
          END_DATE="2026-08-15"

          # Check if date is excluded
          for excluded in "${EXCLUDED_DATES[@]}"; do
            if [ "$TARGET_DATE" = "$excluded" ]; then
              echo "❌ Date $TARGET_DATE is excluded (holiday/break)"
              echo "Excluded dates: ${EXCLUDED_DATES[*]}"
              exit 1
            fi
          done

          # Check if date is after end date
          if [[ "$TARGET_DATE" > "$END_DATE" ]]; then
            echo "❌ Date $TARGET_DATE is after experiment end date ($END_DATE)"
            echo "The experiment concluded on $END_DATE"
            exit 1
          fi

          echo "✅ Date $TARGET_DATE is valid"
          echo "Experiment runs until: $END_DATE"
          echo "Excluded dates: ${EXCLUDED_DATES[*]}"

      - name: Run plan.py
        id: plan
        run: |
          DATE="${{ steps.date.outputs.next_saturday }}"
          IS_WEEK_1="${{ inputs.is_week_1 }}"

          # Auto-detect is_week_1 based on date (for scheduled runs)
          if [ -z "$IS_WEEK_1" ]; then
            # Week 1 dates for each experiment phase
            # Pilot: 2025-12-27
            # Official: 2026-01-10
            if [ "$DATE" = "2025-12-27" ] || [ "$DATE" = "2026-01-10" ]; then
              IS_WEEK_1="true"
              echo "Auto-detected: This is Week 1 of the experiment phase (24 DH, no D2DS)"
            else
              IS_WEEK_1="false"
              echo "Auto-detected: This is Week 2+ (6 DH + 6 D2DS)"
            fi
          fi

          echo "Generating plan for $DATE (is_week_1=$IS_WEEK_1)..."
          echo "Note: Experiment phase (pilot/official) will be auto-detected based on date"

          # Run plan.py
          python -c "
          import sys
          sys.path.insert(0, 'src')
          from sd311_fieldprep.plan import run_plan

          date = '$DATE'
          is_week_1 = '$IS_WEEK_1' == 'true'

          print(f'Running plan for {date} (is_week_1={is_week_1})...')

          plan_csv = run_plan(
              date=date,
              interviewers=('A', 'B', 'C', 'D', 'E', 'F'),
              tasks=('DH', 'D2DS'),
              list_code=30,
              seed=42,
              bundle_file='outputs/bundles/DH/bundles_multibfs_regroup_filtered_length_3.parquet',
              is_week_1=is_week_1
          )
          print(f'Plan created: {plan_csv}')
          " | tee plan_output.log

          # Extract plan CSV path from output
          PLAN_CSV=$(grep "Plan created:" plan_output.log | sed 's/Plan created: //')
          echo "plan_csv=$PLAN_CSV" >> $GITHUB_OUTPUT
          echo "Plan CSV: $PLAN_CSV"

      - name: Run emit.py
        run: |
          DATE="${{ steps.date.outputs.next_saturday }}"
          PLAN_CSV="${{ steps.plan.outputs.plan_csv }}"

          echo "Running emit for $DATE..."

          python -c "
          import sys
          sys.path.insert(0, 'src')
          from sd311_fieldprep.emit import run_emit

          run_emit(
              date='$DATE',
              plan_csv='$PLAN_CSV',
              bundle_file='outputs/bundles/DH/bundles_multibfs_regroup_filtered_length_3.parquet',
              addr_assignment_file='outputs/sweep/locked/segment_addresses_b40_m2.parquet'
          )
          print('Emit completed!')
          "

      - name: Commit and push plan files to repository
        run: |
          DATE="${{ steps.date.outputs.next_saturday }}"
          PLAN_CSV="${{ steps.plan.outputs.plan_csv }}"
          SEGMENT_CSV="outputs/plans/segment_assignments_$DATE.csv"

          echo "Committing plan files to repository..."
          echo "This ensures future runs can track used bundles and segment assignments"

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Add plan CSV and segment assignments CSV
          git add "$PLAN_CSV"
          if [ -f "$SEGMENT_CSV" ]; then
            git add "$SEGMENT_CSV"
            echo "✓ Added segment assignments file: $SEGMENT_CSV"
          else
            echo "⚠ Segment assignments file not found: $SEGMENT_CSV"
          fi

          # Only commit if there are changes
          if git diff --staged --quiet; then
            echo "No changes to commit (files already exist)"
          else
            git commit -m "Add plan and segment assignments for $DATE [automated]"
            git push
            echo "✓ Plan files committed and pushed to repository"
          fi

      - name: Prepare upload directory
        id: prepare
        run: |
          DATE="${{ steps.date.outputs.next_saturday }}"
          UPLOAD_DIR="outputs/incoming/daily/$DATE"

          echo "upload_dir=$UPLOAD_DIR" >> $GITHUB_OUTPUT

          # List generated files
          echo "Generated files:"
          ls -lh "$UPLOAD_DIR"

      - name: Upload to Google Drive
        env:
          GOOGLE_DRIVE_OAUTH_CREDENTIALS: ${{ secrets.GOOGLE_DRIVE_OAUTH_CREDENTIALS }}
          GOOGLE_DRIVE_FOLDER_ID: ${{ secrets.GOOGLE_DRIVE_FOLDER_ID }}
        run: |
          DATE="${{ steps.date.outputs.next_saturday }}"
          UPLOAD_DIR="outputs/incoming/daily/$DATE"

          echo "Uploading to Google Drive..."
          python scripts/upload_to_drive.py \
            "$UPLOAD_DIR" \
            "$GOOGLE_DRIVE_FOLDER_ID" \
            --oauth-credentials "$GOOGLE_DRIVE_OAUTH_CREDENTIALS"

      - name: Upload segment_analysis to Google Drive routing folder
        env:
          GOOGLE_DRIVE_OAUTH_CREDENTIALS: ${{ secrets.GOOGLE_DRIVE_OAUTH_CREDENTIALS }}
          GOOGLE_DRIVE_ROUTING_FOLDER_ID: ${{ secrets.GOOGLE_DRIVE_ROUTING_FOLDER_ID }}
        run: |
          DATE="${{ steps.date.outputs.next_saturday }}"
          ROUTING_DIR="outputs/routing/segment_analysis/$DATE"

          echo "Uploading segment_analysis.csv to Google Drive routing folder..."
          python scripts/upload_to_drive.py \
            "$ROUTING_DIR" \
            "$GOOGLE_DRIVE_ROUTING_FOLDER_ID" \
            --oauth-credentials "$GOOGLE_DRIVE_OAUTH_CREDENTIALS"

      - name: Send success notification
        if: success()
        run: |
          DATE="${{ steps.date.outputs.next_saturday }}"
          echo "✅ Weekly plan and emit completed successfully for $DATE"
          echo "Files uploaded to Google Drive"

      - name: Send failure notification
        if: failure()
        run: |
          DATE="${{ steps.date.outputs.next_saturday }}"
          echo "❌ Weekly plan and emit failed for $DATE"
          echo "Check the logs for details"

      - name: Archive logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: plan-emit-logs-${{ steps.date.outputs.next_saturday }}
          path: |
            plan_output.log
            outputs/incoming/daily/${{ steps.date.outputs.next_saturday }}/*.csv
          retention-days: 30
